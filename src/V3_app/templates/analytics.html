{% extends "base.html" %}

{% block title %}Analytics - Financial App V3{% endblock %}

{% block head_extra %}
    {# Add any page-specific CSS or meta tags here if needed later #}
    {# --- Add Chart.js CDN --- #}
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    {# --- End Chart.js CDN --- #}
    <style>
        /* Style for filter rows */
        .filter-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border: 1px solid var(--bs-border-color-translucent);
            border-radius: 0.25rem;
        }
        .filter-row select,
        .filter-row input {
            margin-right: 0.5rem;
        }
        /* Style for output area */
        #processed-analytics-output {
            background-color: var(--bs-body-bg); /* Use CSS var for theme adapt */
            border: 1px solid var(--bs-border-color); /* Use CSS var for theme adapt */
            color: var(--bs-body-color); /* Ensure text color matches theme */
            padding: 15px;
            margin-top: 15px;
            max-height: 600px; /* Increased height */
            overflow-y: auto;
            white-space: pre-wrap; /* Allow wrapping */
            word-wrap: break-word; /* Break long words/strings */
            font-family: monospace; /* Good for JSON */
            font-size: 0.85rem;
        }
        /* Style for drag-and-drop area */
        #drop-zone {
            border: 2px dashed var(--bs-secondary-color);
            border-radius: 0.375rem; /* Match Bootstrap's default border radius */
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            background-color: var(--bs-tertiary-bg);
            transition: border-color 0.3s ease, background-color 0.3s ease;
        }
        #drop-zone.dragover {
            border-color: var(--bs-primary);
            background-color: var(--bs-primary-bg-subtle);
        }
        #drop-zone p {
            margin-bottom: 0;
            color: var(--bs-body-color); /* Use main body color for better contrast */
        }
    </style>
{% endblock %}

{% block content %}
    {# Analytics Page Content #}
    <h1>Analytics</h1>
    <p>import, process, filter, configure, and report on financial data.</p>

    {# --- Main Tab Navigation --- #}
    <ul class="nav nav-tabs mt-3" id="mainAnalyticsTabs" role="tablist">
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="data-import-tab" data-bs-toggle="tab" data-bs-target="#data-import-tab-pane" type="button" role="tab" aria-controls="data-import-tab-pane" aria-selected="true">Data Import</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="data-prep-tab" data-bs-toggle="tab" data-bs-target="#data-prep-tab-pane" type="button" role="tab" aria-controls="data-prep-tab-pane" aria-selected="false">Data Preparation</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="data-report-tab" data-bs-toggle="tab" data-bs-target="#data-report-tab-pane" type="button" role="tab" aria-controls="data-report-tab-pane" aria-selected="false">Analysis & Reports</button>
        </li>
    </ul>
    {# --- End Main Tab Navigation --- #}

    {# --- Main Tab Content --- #}
    <div class="tab-content pt-3" id="mainAnalyticsTabsContent">

        {# --- Data Import Tab Pane --- #}
        <div class="tab-pane fade show active" id="data-import-tab-pane" role="tabpanel" aria-labelledby="data-import-tab" tabindex="0">
            <h5>Data Import Sources</h5>
            <p>Import raw data from external sources.</p>

            {# --- Finviz Import Card --- #}
            <div class="my-3 p-3 border rounded bg-body-tertiary">
                <h5 class="mb-3">Import from Finviz</h5>
                <div class="row gy-3"> {# Use row with gutter spacing #}
                    
                    {# --- Column 1: Screened Tickers --- #}
                    <div class="col-md-6">
                        <h6>All Tracked Tickers</h6>
                        <p class="small text-muted mb-2">Fetch data for tickers currently in the <strong>tracker list</strong>.</p>
                        <button id="run-finviz-btn" class="btn btn-primary" style="max-width: 200px;">
                            <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true" style="display: none;"></span> <!-- Spinner -->
                            <span class="button-text">Fetch Tracked</span> <!-- Text -->
                        </button>
                         <span id="finviz-status" class="ms-1 mt-1 d-block small"></span> {# Moved status below button #}
                    </div>
                    {# --- End Column 1 --- #}

                    {# --- Column 2: Custom List --- #}
                    <div class="col-md-6">
                        <h6>Custom List</h6>
                        <p class="small text-muted mb-2">Upload a .txt file (one ticker per line).</p>
                        
                        {# Button First #}
                        <button id="run-finviz-upload-btn" class="btn btn-primary mb-2" disabled style="max-width: 200px;">
                            <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true" style="display: none;"></span> <!-- Spinner -->
                            <span class="button-text">Fetch Uploaded</span> <!-- Text -->
                        </button>
                        <span id="finviz-upload-status" class="ms-1 mt-1 d-block small mb-2"></span> {# Status below button #}

                        {# Hidden File Input #}
                        <input type="file" id="ticker-file-input" accept=".txt" style="display: none;">

                        {# Drag and Drop Zone Below Button #}
                        <div id="drop-zone" class="mb-2" style="max-width: 200px;"> {# Apply max-width #}
                            <p>
                                <span class="status-icon bi bi-cloud-arrow-up me-2 align-middle"></span> {# Icon holder #}
                                <span class="status-text">Drag & drop .txt file or click</span> {# Text holder #}
                            </p>
                        </div>
                        
                    </div>
                    {# --- End Column 2 --- #}
                </div>
            </div>
            {# --- End Finviz Import Card --- #}

            {# --- Placeholder for Future Import Sources --- #}
            <!-- 
            <div class="my-3 p-3 border rounded bg-body-tertiary">
                <h5 class="mb-3">Import from [Other Source]</h5>
                </div>
            -->
            {# --- End Placeholder --- #}

        </div>
        {# --- End Data Import Tab Pane --- #}

        {# --- Data Preparation Tab Pane --- #}
        <div class="tab-pane fade" id="data-prep-tab-pane" role="tabpanel" aria-labelledby="data-prep-tab" tabindex="0">
            <h5>Data Preparation Steps</h5>
            <p>Process, clean, filter, and configure the imported data.</p>

            {# --- Raw Analytics Data Processing, Filtering & Configuration --- #}
            <div class="my-3 p-3 border rounded bg-body-tertiary">
                <h6>Process, Filter & Configure Raw Analytics Data</h6>

                {# Processing Button (outside sub-tabs) #}
                <div class="mb-3 pb-3 border-bottom">
                    <p class="small text-muted">Load and process all raw analytics data currently stored in the database.</p>
                    <button id="process-analytics-data-btn" class="btn btn-secondary me-2">Load Data from DB</button>
                    <span id="process-analytics-status" class="ms-2"></span> {# Status for the processing action #}
                </div>

                {# --- Sub-Tab Navigation for Prep Steps --- #}
                <ul class="nav nav-tabs mt-3" id="prepStepsTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="filter-subtab" data-bs-toggle="tab" data-bs-target="#filter-subtab-pane" type="button" role="tab" aria-controls="filter-subtab-pane" aria-selected="true">Filters & Output</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="config-subtab" data-bs-toggle="tab" data-bs-target="#config-subtab-pane" type="button" role="tab" aria-controls="config-subtab-pane" aria-selected="false">Field Configuration</button>
                    </li>
                </ul>
                {# --- End Sub-Tab Navigation --- #}

                {# --- Sub-Tab Content --- #}
                <div class="tab-content pt-3" id="prepStepsTabsContent">

                    {# --- Filters & Output Sub-Tab Pane --- #}
                    <div class="tab-pane fade show active" id="filter-subtab-pane" role="tabpanel" aria-labelledby="filter-subtab" tabindex="0">

                        {# Filter Controls #}
                        <div class="mb-3">
                            <h6>Filter Criteria:</h6>
                            <div id="filter-controls-container">
                                <!-- Filter rows will be added here dynamically -->
                            </div>
                            <button id="add-filter-btn" class="btn btn-sm btn-outline-success me-2">+ Add Filter</button>
                            <button id="apply-filters-btn" class="btn btn-sm btn-primary me-2">Apply Filters</button>
                            <button id="reset-filters-btn" class="btn btn-sm btn-outline-danger">Reset Filters</button>
                        </div>

                        {# Display area for processed output #}
                        <div id="processed-analytics-output-container" class="mt-3">
                            <h6>Filtered Output:</h6> <span id="filter-results-count" class="ms-2 small text-muted"></span>
                            <pre id="processed-analytics-output"></pre>
                        </div>

                    </div>
                    {# --- End Filters & Output Sub-Tab Pane --- #}

                    {# --- Field Configuration Sub-Tab Pane --- #}
                    <div class="tab-pane fade" id="config-subtab-pane" role="tabpanel" aria-labelledby="config-subtab" tabindex="0">

                        {# Container for Field Weights & Toggles #}
                        <div class="mb-3">
                            <h6>Field Configuration (Weights & Enabled Status):</h6>
                            <div id="field-config-container" style="max-height: 400px; overflow-y: auto;"> <!-- Increased height slightly -->
                                <!-- Field config rows will be added here dynamically -->
                                <p class="text-muted small">Load data to configure fields.</p>
                            </div>
                            <!-- Optional: Add a "Save Weights/Toggles" or "Reset Weights/Toggles" button here later -->
                        </div>

                    </div>
                    {# --- End Field Configuration Sub-Tab Pane --- #}

                </div>
                {# --- End Sub-Tab Content --- #}

            </div>
            {# --- END Raw Analytics Data Processing, Filtering & Configuration --- #}

            {# Add other prep steps here later #}

        </div>
        {# --- End Data Preparation Tab Pane --- #}

        {# --- Data Report Tab Pane --- #}
        <div class="tab-pane fade" id="data-report-tab-pane" role="tabpanel" aria-labelledby="data-report-tab" tabindex="0">
            <h5>Data Reporting</h5>
            <p>Generate reports, visualizations, or summaries based on the prepared data.</p>
            
            {# --- Chart Controls & Display --- #}
            <div class="my-3 p-3 border rounded bg-body-tertiary">
                <div class="row mb-3">
                    <div class="col-md-4">
                        <label for="report-field-selector" class="form-label">Select Field for Chart (Y-axis):</label>
                        <select id="report-field-selector" class="form-select form-select-sm">
                            <option value="">-- Select Field --</option>
                            {# Options will be populated by JavaScript #}
                        </select>
                    </div>
                    {# --- NEW: Color By Selector --- #}
                    <div class="col-md-4">
                        <label for="report-color-selector" class="form-label">Color Points By Field:</label>
                        <select id="report-color-selector" class="form-select form-select-sm">
                            <option value="">-- No Color Variation --</option>
                            {# Options will be populated by JavaScript #}
                        </select>
                    </div>
                    {# --- END: Color By Selector --- #}
                    {# Add placeholder for potential chart type selector later #}
                    <!-- <div class="col-md-4">
                        <label for="report-chart-type-selector" class="form-label">Chart Type:</label>
                        <select id="report-chart-type-selector" class="form-select form-select-sm">
                            <option value="scatter" selected>Scatter Plot</option>
                             Add other chart types here later 
                        </select>
                    </div> -->
                </div>
                <div id="report-chart-container" style="position: relative; height:40vh; width:80vw">
                    <canvas id="report-chart-canvas"></canvas>
                </div>
                <div id="chart-status" class="mt-2 small text-muted"></div>
            </div>
            {# --- End Chart Controls & Display --- #}

            <p class="text-muted small"><i>(Other reporting features will be added here later)</i></p>
        </div>
        {# --- End Data Report Tab Pane --- #}

    </div>
    {# --- End Main Tab Content --- #}

    <!-- Add other analytics-specific content here later -->
{% endblock %}

{% block scripts %}
    {# Add any page-specific JavaScript here if needed later #}
    <script>
        document.addEventListener('DOMContentLoaded', function() { // No longer needs to be async
            // --- Global variables ---
            let fullProcessedData = [];
            let currentFilters = [];
            let fieldWeights = {};      // {fieldName: weight (0-100)}
            let availableFields = [];
            let fieldMetadata = {};
            let fieldEnabledStatus = {}; // {fieldName: true/false}
            let uploadedTickers = []; // To store tickers from uploaded file

            const FILTER_STORAGE_KEY = 'analyticsAnalyticsFilters';
            const WEIGHT_STORAGE_KEY = 'analyticsAnalyticsFieldWeights';
            const FIELD_ENABLED_STORAGE_KEY = 'analyticsAnalyticsFieldEnabled'; // New key

            // --- Element References ---
            // Import Tab
            const finvizButton = document.getElementById('run-finviz-btn');
            const finvizStatus = document.getElementById('finviz-status');
            const dropZone = document.getElementById('drop-zone');
            const tickerFileInput = document.getElementById('ticker-file-input');
            const runFinvizUploadBtn = document.getElementById('run-finviz-upload-btn');
            const finvizUploadStatus = document.getElementById('finviz-upload-status');

            // Preparation Tab
            const processButton = document.getElementById('process-analytics-data-btn');
            const processStatus = document.getElementById('process-analytics-status');
            const outputArea = document.getElementById('processed-analytics-output');
            const filterControlsContainer = document.getElementById('filter-controls-container');
            const addFilterBtn = document.getElementById('add-filter-btn');
            const applyFiltersBtn = document.getElementById('apply-filters-btn');
            const resetFiltersBtn = document.getElementById('reset-filters-btn');
            const filterResultsCount = document.getElementById('filter-results-count');
            const fieldConfigContainer = document.getElementById('field-config-container');

            // Report Tab (NEW)
            const reportFieldSelector = document.getElementById('report-field-selector');
            const reportChartCanvas = document.getElementById('report-chart-canvas');
            const chartStatus = document.getElementById('chart-status');
            const reportColorSelector = document.getElementById('report-color-selector'); // NEW
            let reportChartInstance = null; // To hold the chart object
            let filteredDataForChart = []; // Store data used for the current chart

            // --- File Handling Logic (Import Tab) ---
            function handleFile(file) {
                const dropZoneP = dropZone.querySelector('p');
                const iconSpan = dropZoneP ? dropZoneP.querySelector('span.status-icon') : null;
                const textSpan = dropZoneP ? dropZoneP.querySelector('span.status-text') : null; // Target text span

                if (!file) {
                    if (dropZoneP && iconSpan && textSpan) {
                        textSpan.textContent = 'Drag & drop ticker file here (.txt only), or click to select'; // Use textContent
                        iconSpan.className = 'status-icon bi bi-cloud-arrow-up me-2 align-middle text-muted'; // Default icon + color
                    }
                    runFinvizUploadBtn.disabled = true; // Disable button if no file
                    uploadedTickers = [];
                    return;
                }

                if (!file.name.endsWith('.txt')) {
                    if (dropZoneP && iconSpan && textSpan) {
                        textSpan.textContent = `Invalid file: ${file.name}. Please use a .txt file.`; // Use textContent
                        iconSpan.className = 'status-icon bi bi-x-octagon-fill me-2 align-middle text-danger'; // Error icon + color
                    }
                    runFinvizUploadBtn.disabled = true; // Disable button if invalid file
                    uploadedTickers = [];
                    tickerFileInput.value = ''; // Reset file input
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(event) {
                    const content = event.target.result;
                    const lines = content.split(/\r?\n/);
                    uploadedTickers = lines
                        .map(line => line.trim().toUpperCase())
                        .filter(line => line.length > 0 && line.length <= 10);

                    if (dropZoneP && iconSpan && textSpan) {
                        if (uploadedTickers.length > 0) {
                            textSpan.textContent = `File: ${file.name} (${uploadedTickers.length} tickers found)`; // Use textContent
                            iconSpan.className = 'status-icon bi bi-check-circle-fill me-2 align-middle text-success'; // Success icon + color
                            
                            // Enable upload button ONLY if the other button is not currently running
                            if (!finvizButton.disabled || finvizButton.querySelector('.spinner-border').style.display === 'none') {
                                runFinvizUploadBtn.disabled = false;
                            }
                            
                            finvizUploadStatus.textContent = '';
                            console.log("Tickers from file:", uploadedTickers);
                        } else {
                            textSpan.textContent = `File: ${file.name} - No valid tickers found.`; // Use textContent
                            iconSpan.className = 'status-icon bi bi-exclamation-triangle-fill me-2 align-middle text-warning'; // Warning icon + color
                            runFinvizUploadBtn.disabled = true; // Disable button if no valid tickers
                            uploadedTickers = [];
                        }
                    }
                };
                reader.onerror = function(event) {
                    console.error("File reading error:", event);
                    if (dropZoneP && iconSpan && textSpan) {
                        textSpan.textContent = `Error reading file: ${file.name}`; // Use textContent
                        iconSpan.className = 'status-icon bi bi-shield-exclamation me-2 align-middle text-danger'; // Error icon + color
                    }
                    runFinvizUploadBtn.disabled = true; // Disable button on error
                    uploadedTickers = [];
                };
                reader.readAsText(file);
            }

            if (dropZone && tickerFileInput) {
                // Click drop zone triggers file input
                dropZone.addEventListener('click', () => tickerFileInput.click());

                // Drag events
                dropZone.addEventListener('dragover', (event) => {
                    event.preventDefault(); // Prevent default browser behavior
                    dropZone.classList.add('dragover');
                });
                dropZone.addEventListener('dragleave', (event) => {
                    dropZone.classList.remove('dragover');
                });
                dropZone.addEventListener('drop', (event) => {
                    event.preventDefault(); // Prevent default browser behavior
                    dropZone.classList.remove('dragover');
                    if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
                        const file = event.dataTransfer.files[0];
                        tickerFileInput.files = event.dataTransfer.files; // Assign files to input for consistency
                        handleFile(file);
                        event.dataTransfer.clearData();
                    }
                });

                // File input change event
                tickerFileInput.addEventListener('change', (event) => {
                    if (event.target.files && event.target.files.length > 0) {
                        handleFile(event.target.files[0]);
                    }
                });
            }

            // --- Button Listeners (Import Tab) ---
            // 1. Fetch for Screened Tickers
            if (finvizButton && finvizStatus) {
                finvizButton.addEventListener('click', async function() {
                    // Disable both buttons and show spinner on the clicked one
                    showSpinner(finvizButton, runFinvizUploadBtn);
                    finvizStatus.textContent = 'Starting fetch job...';
                    finvizStatus.className = 'ms-2 text-info';
                    let eventSource = null; // Variable to hold EventSource connection

                    try {
                        console.log("Calling /api/analytics/start-finviz-fetch-screener endpoint...");
                        const response = await fetch('/api/analytics/start-finviz-fetch-screener', {
                            method: 'POST',
                            headers: { 'Accept': 'application/json' }
                        });
                        const result = await response.json();

                        if (!response.ok) {
                            const errorDetail = result.detail || `Fetch trigger failed with status ${response.status} - ${response.statusText}`;
                            console.error("Error response from start-finviz-fetch-screener:", result);
                            throw new Error(errorDetail);
                        }

                        console.log("Fetch job triggered:", result);

                        // --- SSE Integration --- 
                        if (result.job_id) {
                            console.log(`Received job_id: ${result.job_id}. Establishing SSE connection.`);
                            finvizStatus.textContent = `${result.message || 'Fetch job triggered.'} Waiting for completion...`;
                            finvizStatus.className = 'ms-2 text-info';

                            eventSource = new EventSource(`/api/analytics/stream-job-status/${result.job_id}`);

                            eventSource.onmessage = function(event) {
                                console.log("SSE message received:", event.data);
                                try {
                                    const data = JSON.parse(event.data);
                                    let isFinalStatus = false; // Flag to check if it's a terminal state

                                    if (data.status === 'completed') {
                                        finvizStatus.textContent = data.message || 'Job completed successfully.';
                                        finvizStatus.className = 'ms-2 text-success';
                                        console.log("Job completed via SSE.");
                                        isFinalStatus = true;
                                    } else if (data.status === 'failed') {
                                        finvizStatus.textContent = `Error: ${data.message || 'Job failed.'}`;
                                        finvizStatus.className = 'ms-2 text-danger';
                                        console.error("Job failed via SSE:", data.message);
                                        isFinalStatus = true;
                                    } else if (data.status === 'partial_failure') { // <<< ADD HANDLING FOR PARTIAL FAILURE
                                        finvizStatus.textContent = data.message || 'Job completed with some failures.';
                                        finvizStatus.className = 'ms-2 text-warning'; // Use warning color
                                        console.warn("Job completed with partial failure via SSE:", data.message);
                                        isFinalStatus = true;
                                    } else {
                                        // Handle intermediate statuses if backend sends them
                                        finvizStatus.textContent = data.message || 'Job in progress...'; 
                                        finvizStatus.className = 'ms-2 text-info';
                                    }
                                    // Close connection and re-enable button on final status
                                    if (isFinalStatus) { // <<< Check the flag
                                        eventSource.close();
                                        console.log("SSE connection closed.");
                                        // Re-enable both buttons (conditionally for upload button)
                                        hideSpinner(finvizButton, runFinvizUploadBtn);
                                    }
                                } catch (e) {
                                    console.error("Error parsing SSE message:", e);
                                    finvizStatus.textContent = 'Error processing status update.';
                                    finvizStatus.className = 'ms-2 text-warning';
                                    eventSource.close(); // Close on parsing error
                                    hideSpinner(finvizButton, runFinvizUploadBtn); // Re-enable both
                                }
                            };

                            eventSource.onerror = function(error) {
                                console.error("SSE connection error:", error);
                                // Update status only if it hasn't already shown completion/failure
                                if (!finvizStatus.classList.contains('text-success') && !finvizStatus.classList.contains('text-danger')) {
                                     finvizStatus.textContent = 'Error receiving status updates. Check console.';
                                     finvizStatus.className = 'ms-2 text-warning';
                                }
                                eventSource.close(); // Ensure connection is closed
                                hideSpinner(finvizButton, runFinvizUploadBtn); // Re-enable both
                            };

                        } else {
                            // If no job_id received, handle as before (show initial message)
                            console.warn("No job_id received in response. Cannot track completion status.");
                            finvizStatus.textContent = result.message || 'Fetch job triggered successfully.';
                            finvizStatus.className = 'ms-2 text-success';
                            hideSpinner(finvizButton, runFinvizUploadBtn); // Re-enable both
                        }
                        // --- End SSE Integration ---

                    } catch (error) {
                        console.error('Error triggering Finviz fetch for screened tickers:', error);
                        finvizStatus.textContent = `Error: ${error.message || 'An unknown error occurred.'}`;
                        finvizStatus.className = 'ms-2 text-danger';
                        if (eventSource) eventSource.close(); // Close SSE if open
                        hideSpinner(finvizButton, runFinvizUploadBtn); // Re-enable both
                    } // No finally block needed as button re-enabled within logic
                });
            }

            // 2. Fetch for Uploaded Tickers
            if (runFinvizUploadBtn && finvizUploadStatus) {
                runFinvizUploadBtn.addEventListener('click', async function() {
                    if (uploadedTickers.length === 0) {
                        finvizUploadStatus.textContent = 'No tickers loaded from file.';
                        finvizUploadStatus.className = 'ms-2 text-warning';
                        return;
                    }

                    // Disable both buttons and show spinner on the clicked one
                    showSpinner(runFinvizUploadBtn, finvizButton);
                    finvizUploadStatus.textContent = `Starting fetch job for ${uploadedTickers.length} tickers...`;
                    finvizUploadStatus.className = 'ms-2 text-info';
                    let eventSourceUpload = null; // Variable for this button's EventSource

                    try {
                        console.log("Calling endpoint /api/analytics/start-finviz-fetch-upload with tickers:", uploadedTickers);

                        const response = await fetch('/api/analytics/start-finviz-fetch-upload', { // <-- Use new endpoint
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Accept': 'application/json'
                            },
                            body: JSON.stringify({ tickers: uploadedTickers }) // Send tickers in correct format
                        });
                        const result = await response.json();

                        if (!response.ok) {
                            const errorDetail = result.detail || `Fetch trigger failed with status ${response.status} - ${response.statusText}`;
                            console.error("Error response from start-finviz-fetch-upload:", result);
                            throw new Error(errorDetail);
                        }
                        console.log("Fetch job triggered successfully:", result);

                        // --- SSE Integration for Upload --- 
                        if (result.job_id) {
                             console.log(`Received job_id: ${result.job_id}. Establishing SSE connection for upload.`);
                             finvizUploadStatus.textContent = `${result.message || 'Fetch job triggered.'} Waiting for completion...`;
                             finvizUploadStatus.className = 'ms-2 text-info';

                             eventSourceUpload = new EventSource(`/api/analytics/stream-job-status/${result.job_id}`);

                             eventSourceUpload.onmessage = function(event) {
                                 console.log("SSE message received (upload):", event.data);
                                 try {
                                     const data = JSON.parse(event.data);
                                     let isFinalStatus = false; // Flag

                                     if (data.status === 'completed') {
                                         finvizUploadStatus.textContent = data.message || 'Job completed successfully.';
                                         finvizUploadStatus.className = 'ms-2 text-success';
                                         console.log("Upload job completed via SSE.");
                                         isFinalStatus = true;
                                     } else if (data.status === 'failed') {
                                         finvizUploadStatus.textContent = `Error: ${data.message || 'Job failed.'}`;
                                         finvizUploadStatus.className = 'ms-2 text-danger';
                                         console.error("Upload job failed via SSE:", data.message);
                                         isFinalStatus = true;
                                     } else if (data.status === 'partial_failure') { // <<< ADD HANDLING FOR PARTIAL FAILURE
                                        finvizUploadStatus.textContent = data.message || 'Job completed with some failures.';
                                        finvizUploadStatus.className = 'ms-2 text-warning'; // Use warning color
                                        console.warn("Upload job completed with partial failure via SSE:", data.message);
                                        isFinalStatus = true;
                                     } else {
                                         finvizUploadStatus.textContent = data.message || 'Job in progress...'; 
                                         finvizUploadStatus.className = 'ms-2 text-info';
                                     }
                                     // Close connection and re-enable button on final status
                                     if (isFinalStatus) { // <<< Check the flag
                                         eventSourceUpload.close();
                                         console.log("SSE connection closed (upload).");
                                         // Re-enable both buttons (conditionally for upload button)
                                         hideSpinner(runFinvizUploadBtn, finvizButton);
                                     }
                                 } catch (e) {
                                     console.error("Error parsing SSE message (upload):", e);
                                     finvizUploadStatus.textContent = 'Error processing status update.';
                                     finvizUploadStatus.className = 'ms-2 text-warning';
                                     eventSourceUpload.close(); // Close on error
                                     hideSpinner(runFinvizUploadBtn, finvizButton); // Re-enable both
                                 }
                             };

                             eventSourceUpload.onerror = function(error) {
                                 console.error("SSE connection error (upload):", error);
                                 // Update status only if it hasn't already shown completion/failure
                                 if (!finvizUploadStatus.classList.contains('text-success') && !finvizUploadStatus.classList.contains('text-danger')) {
                                     finvizUploadStatus.textContent = 'Error receiving status updates. Check console.';
                                     finvizUploadStatus.className = 'ms-2 text-warning';
                                 }
                                 eventSourceUpload.close(); // Ensure closed
                                 hideSpinner(runFinvizUploadBtn, finvizButton); // Re-enable both
                             };

                         } else {
                             // If no job_id received, handle as before
                             console.warn("No job_id received in upload response. Cannot track completion status.");
                             finvizUploadStatus.textContent = result.message || 'Fetch job triggered successfully.';
                             finvizUploadStatus.className = 'ms-2 text-success';
                             hideSpinner(runFinvizUploadBtn, finvizButton); // Re-enable both
                         }
                         // --- End SSE Integration for Upload ---

                    } catch (error) {
                        console.error('Error triggering Finviz fetch for uploaded tickers:', error);
                        finvizUploadStatus.textContent = `Error: ${error.message || 'An unknown error occurred.'}`;
                        finvizUploadStatus.className = 'ms-2 text-danger';
                         if (eventSourceUpload) eventSourceUpload.close(); // Close SSE if open
                         hideSpinner(runFinvizUploadBtn, finvizButton); // Re-enable both
                    } // No finally block needed
                });
            }

            // --- Storage & State Functions (Preparation Tab) ---
            function loadFiltersFromStorage() {
                console.log("Loading filters from localStorage...");
                const savedFilters = localStorage.getItem(FILTER_STORAGE_KEY);
                let loaded = [];
                if (savedFilters) {
                    try {
                        loaded = JSON.parse(savedFilters);
                        if (!Array.isArray(loaded)) loaded = [];
                    } catch (e) {
                        console.error("Error parsing saved filters:", e);
                        loaded = [];
                        localStorage.removeItem(FILTER_STORAGE_KEY);
                    }
                } else {
                    console.log("No saved filters found.");
                }

                // Ensure structure (id, field, operator, value, comment)
                currentFilters = loaded.map(f => ({
                    id: f.id || Date.now() + Math.random(), // Add random for better uniqueness if needed
                    field: f.field || '',
                    operator: f.operator || '=',
                    value: f.value !== undefined ? f.value : '',
                    comment: f.comment || '' // Add comment field with default
                }));

                console.log("Processed loaded/default filters:", currentFilters);

                // Add default blank filter if none loaded
                if (currentFilters.length === 0) {
                    currentFilters.push({ id: Date.now() + Math.random(), field: '', operator: '=', value: '', comment: '' }); // Add comment
                    console.log("Added default blank filter.");
                }
            }

            function saveFiltersToStorage() {
                 if (!Array.isArray(currentFilters)) {
                     console.error("Attempted to save non-array filters:", currentFilters);
                     return;
                 }
                // Save id, field, operator, value, comment
                const filtersToSave = currentFilters.map(f => ({
                     id: f.id,
                     field: f.field,
                     operator: f.operator,
                     value: f.value,
                     comment: f.comment // Add comment field
                 }));
                console.log("Saving filters to localStorage:", filtersToSave);
                try {
                     localStorage.setItem(FILTER_STORAGE_KEY, JSON.stringify(filtersToSave));
                } catch (e) {
                    console.error("Error saving filters to localStorage:", e);
                }
            }

            function loadWeightsFromStorage() {
                console.log("Loading weights from localStorage...");
                const savedWeights = localStorage.getItem(WEIGHT_STORAGE_KEY);
                let loaded = {}; // Load into temp object first
                if (savedWeights) {
                    try {
                        loaded = JSON.parse(savedWeights);
                        if (typeof loaded !== 'object' || loaded === null || Array.isArray(loaded)) {
                            loaded = {}; // Reset if not a valid object
                        }
                    } catch (e) {
                        console.error("Error parsing saved weights:", e);
                        loaded = {};
                        localStorage.removeItem(WEIGHT_STORAGE_KEY);
                    }
                }
                // Process loaded weights, ensuring they are numbers 0-100
                const processedWeights = {};
                for (const field in loaded) {
                    if (loaded.hasOwnProperty(field)) {
                        const weight = Number(loaded[field]);
                        if (!isNaN(weight)) {
                            processedWeights[field] = Math.max(0, Math.min(100, weight)); // Clamp 0-100
                        } else {
                            processedWeights[field] = 100; // Default if stored value invalid
                        }
                    }
                }
                fieldWeights = processedWeights;
                console.log("Loaded field weights:", fieldWeights);
            }

            function saveWeightsToStorage() {
                console.log("Saving weights to localStorage:", fieldWeights);
                try {
                    // Ensure weights are valid numbers before saving?
                    // Or trust the input validation/clamping
                    localStorage.setItem(WEIGHT_STORAGE_KEY, JSON.stringify(fieldWeights));
                } catch (e) {
                    console.error("Error saving weights to localStorage:", e);
                }
            }

            // NEW function for enabled status
            function loadEnabledStatusFromStorage() {
                console.log("Loading enabled status from localStorage...");
                const savedStatus = localStorage.getItem(FIELD_ENABLED_STORAGE_KEY);
                if (savedStatus) {
                    try {
                        fieldEnabledStatus = JSON.parse(savedStatus);
                        if (typeof fieldEnabledStatus !== 'object' || fieldEnabledStatus === null || Array.isArray(fieldEnabledStatus)) {
                            fieldEnabledStatus = {}; // Reset if not valid object
                        }
                        // Ensure all values are boolean
                        for (const field in fieldEnabledStatus) {
                            if (fieldEnabledStatus.hasOwnProperty(field)) {
                                fieldEnabledStatus[field] = Boolean(fieldEnabledStatus[field]);
                            }
                        }
                        console.log("Loaded field enabled status:", fieldEnabledStatus);
                    } catch (e) {
                        console.error("Error parsing saved enabled status:", e);
                        fieldEnabledStatus = {};
                        localStorage.removeItem(FIELD_ENABLED_STORAGE_KEY);
                    }
                } else {
                    fieldEnabledStatus = {}; // Initialize empty if nothing saved
                    console.log("No saved enabled status found.");
                }
            }

            // NEW function for enabled status
            function saveEnabledStatusToStorage() {
                 console.log("Saving enabled status to localStorage:", fieldEnabledStatus);
                 try {
                    localStorage.setItem(FIELD_ENABLED_STORAGE_KEY, JSON.stringify(fieldEnabledStatus));
                 } catch (e) {
                    console.error("Error saving enabled status to localStorage:", e);
                 }
            }

            // --- Helper to update value input based on field metadata (Preparation Tab) ---
            function updateValueInputUI(index, fieldName, inputWrapper, hintSpan) {
                const metadata = fieldMetadata[fieldName];
                inputWrapper.innerHTML = ''; // Clear previous input/select
                hintSpan.textContent = '';
                let currentInput = null;

                // Define a common handler for updating the filter state
                const updateFilterValue = (newValue) => {
                    if (currentFilters[index]) { // Ensure filter still exists
                        currentFilters[index].value = newValue;
                    }
                };

                if (metadata && metadata.type === 'text' && metadata.uniqueValues && metadata.uniqueValues.length > 0) {
                    // --- Create Multi-Select ---
                    hintSpan.textContent = `(${metadata.uniqueValues.length} unique values)`;
                    const select = document.createElement('select');
                    select.multiple = true;
                    select.className = 'form-select form-select-sm w-100';
                    select.size = Math.min(metadata.uniqueValues.length, 4);

                    metadata.uniqueValues.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        // Check if current filter value (which might be an array) includes this option
                        if (currentFilters[index] && Array.isArray(currentFilters[index].value) && currentFilters[index].value.includes(val)) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    });

                    select.addEventListener('change', (e) => {
                        const selectedValues = Array.from(e.target.selectedOptions).map(opt => opt.value);
                        updateFilterValue(selectedValues); // Update state with array
                    });

                    inputWrapper.appendChild(select);
                    currentInput = select;

                } else {
                     // --- Create Text/Number Input ---
                    const input = document.createElement('input');
                    // const datalistId = `datalist-${currentFilters[index].id}`; // Datalist currently disabled
                    input.className = 'form-control form-control-sm';
                    input.placeholder = 'Value';
                    // Ensure value is treated as a string for text input
                    let initialValue = '';
                    if (currentFilters[index]) {
                        const filterVal = currentFilters[index].value;
                        initialValue = Array.isArray(filterVal)
                                        ? '' // Clear if switching from multi-select
                                        : (filterVal !== null && filterVal !== undefined ? String(filterVal) : '');
                    }
                    input.value = initialValue;


                    if (metadata && metadata.type === 'numeric') {
                        hintSpan.textContent = `(Range: ${metadata.min} - ${metadata.max})`;
                        input.type = 'number';
                        input.step = 'any';
                    } else {
                        input.type = 'text';
                        // Add datalist only if simple text and no unique values provided
                        // input.setAttribute('list', datalistId);
                        // const datalist = document.getElementById(datalistId) || document.createElement('datalist');
                        // datalist.id = datalistId;
                        // inputWrapper.appendChild(datalist); // Append datalist if using
                    }
                     if (metadata && metadata.type === 'empty') {
                         hintSpan.textContent = '(No values found in data)';
                     }

                    // Use 'input' event for text/number fields
                    input.addEventListener('input', (e) => {
                         updateFilterValue(e.target.value); // Update state with string value
                    });

                    inputWrapper.appendChild(input);
                    currentInput = input;
                }

                // Hide/Show based on operator (applies to the wrapper now)
                if (currentFilters[index]) {
                    const operator = currentFilters[index].operator;
                    inputWrapper.style.display = (operator === 'exists' || operator === 'notExists') ? 'none' : '';
                    hintSpan.style.display = (operator === 'exists' || operator === 'notExists') ? 'none' : '';
                }
            }

            // --- Render UI Functions (Preparation Tab) ---
            function renderFilterUI() {
                console.log("Rendering filter UI. Available fields:", availableFields, "Enabled Status:", fieldEnabledStatus);
                if (!filterControlsContainer) return; // Check if container exists
                filterControlsContainer.innerHTML = ''; // Clear existing rows

                // Filter available fields based on enabled status
                const enabledFields = availableFields.filter(field => fieldEnabledStatus[field] === true);
                console.log("Rendering filters using enabled fields:", enabledFields);

                if (!currentFilters || currentFilters.length === 0) {
                    filterControlsContainer.innerHTML = '<p class="text-muted small mb-0">No filters defined. Click \'+\' Add Filter.\'</p>';
                    return;
                }

                const operators = [
                    { value: '=', text: '=' },
                    { value: '>', text: '>' },
                    { value: '<', text: '<' },
                    { value: '>=', text: '>=' },
                    { value: '<=', text: '<=' },
                    { value: '!=', text: '!=' },
                    { value: 'contains', text: 'contains' },
                    { value: 'startsWith', text: 'starts with' },
                    { value: 'endsWith', text: 'ends with' },
                    { value: 'exists', text: 'exists (non-empty)'}, // Check if field exists and is not null/empty/None
                    { value: 'notExists', text: 'does not exist / empty'} // Check if field is missing or null/empty/None
                ];

                currentFilters.forEach((filter, index) => {
                    const filterId = filter.id;
                    const row = document.createElement('div');
                    // Use d-flex for the main row container
                    row.className = 'filter-row-container mb-2'; // Container for row + hint
                    row.dataset.filterId = filterId;

                    const filterRowDiv = document.createElement('div');
                    filterRowDiv.className = 'd-flex align-items-center filter-row'; // Flexbox for controls + comment + remove

                    // Field Select (fixed width)
                    const fieldSelect = document.createElement('select');
                    fieldSelect.className = 'form-select form-select-sm me-2 w-auto';
                    fieldSelect.title = 'Select Field';
                    fieldSelect.innerHTML = '<option value="">-- Field --</option>';
                    // Use ONLY enabled fields for the dropdown
                    enabledFields.forEach(fieldName => {
                        const option = document.createElement('option');
                        option.value = fieldName;
                        option.textContent = fieldName;
                        if (filter.field === fieldName) option.selected = true;
                        fieldSelect.appendChild(option);
                    });
                    // If the currently selected filter field is no longer enabled, reset it
                    if (filter.field && !enabledFields.includes(filter.field)) {
                         console.log(`Filter field '${filter.field}' is no longer enabled, resetting filter row ${index}.`);
                         filter.field = '';
                         filter.value = ''; // Reset value too
                         // Might need to save here? Or wait for Apply
                    }
                    filterRowDiv.appendChild(fieldSelect);

                    // Operator Select (fixed width)
                    const operatorSelect = document.createElement('select');
                    operatorSelect.className = 'form-select form-select-sm me-2 w-auto';
                    operatorSelect.title = 'Select Operator';
                    operators.forEach(op => {
                        const option = document.createElement('option');
                        option.value = op.value;
                        option.textContent = op.text;
                        if (filter.operator === op.value) option.selected = true;
                        operatorSelect.appendChild(option);
                    });
                     filterRowDiv.appendChild(operatorSelect);

                    // Value Input Wrapper
                    const valueWrapper = document.createElement('div');
                    // Limit growth and set max-width
                    valueWrapper.className = 'value-input-wrapper me-2';
                    valueWrapper.style.flexGrow = '0'; // Don't allow growth
                    valueWrapper.style.flexShrink = '0'; // Don't allow shrinking either?
                    valueWrapper.style.maxWidth = '250px'; // Set max width to 250px
                    valueWrapper.style.width = '250px'; // Also set width for consistency?
                    filterRowDiv.appendChild(valueWrapper);

                    // Comment Input
                    const commentInput = document.createElement('input');
                    // Allow comment to grow now
                    commentInput.className = 'form-control form-control-sm ms-2 me-2 flex-grow-1';
                    commentInput.style.flexGrow = '1'; // Allow comment to take remaining space
                    commentInput.style.flexShrink = '1'; // Allow shrinking
                    commentInput.style.maxWidth = ''; // Remove previous max width
                    commentInput.placeholder = 'Comment';
                    commentInput.value = filter.comment || '';
                    commentInput.title = 'Filter Comment';
                    filterRowDiv.appendChild(commentInput);

                    // Hint Span
                    const hintSpan = document.createElement('span');
                    hintSpan.className = 'value-hint small text-muted d-block ms-1';

                    // Remove Button
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '×';
                    // Keep ms-auto to push it right
                    removeBtn.className = 'btn btn-sm btn-outline-danger ms-auto';
                    removeBtn.title = 'Remove this filter';
                    removeBtn.style.flexGrow = '0'; // Don't allow button to grow
                    removeBtn.style.flexShrink = '0'; // Don't allow button to shrink
                    removeBtn.addEventListener('click', () => {
                         const indexToRemove = currentFilters.findIndex(f => f.id === filterId);
                         if (indexToRemove > -1) {
                             currentFilters.splice(indexToRemove, 1);
                             saveFiltersToStorage();
                             renderFilterUI();
                         }
                     });
                    filterRowDiv.appendChild(removeBtn);

                    // --- Event Listeners ---
                    fieldSelect.addEventListener('change', (e) => {
                        const indexToUpdate = currentFilters.findIndex(f => f.id === filterId);
                        if (indexToUpdate > -1) {
                            currentFilters[indexToUpdate].field = e.target.value;
                            updateValueInputUI(indexToUpdate, e.target.value, valueWrapper, hintSpan);
                        }
                    });
                     operatorSelect.addEventListener('change', (e) => {
                         const indexToUpdate = currentFilters.findIndex(f => f.id === filterId);
                         if (indexToUpdate > -1) {
                             currentFilters[indexToUpdate].operator = e.target.value;
                             // Update visibility of the wrapper and hint
                             const op = e.target.value;
                             valueWrapper.style.display = (op === 'exists' || op === 'notExists') ? 'none' : '';
                             hintSpan.style.display = (op === 'exists' || op === 'notExists') ? 'none' : '';
                         }
                    });
                     // Note: valueInput listener is now added *inside* updateValueInputUI
                     commentInput.addEventListener('input', (e) => {
                         const indexToUpdate = currentFilters.findIndex(f => f.id === filterId);
                         if (indexToUpdate > -1) {
                             currentFilters[indexToUpdate].comment = e.target.value;
                         }
                    });

                    // Initial UI update for value input based on loaded field
                    // Use findIndex again to ensure we use the correct index after potential resets
                    const currentIndex = currentFilters.findIndex(f => f.id === filterId);
                    if (currentIndex > -1) {
                        updateValueInputUI(currentIndex, filter.field, valueWrapper, hintSpan);
                    }

                    // Append main row and hint to the container
                    row.appendChild(filterRowDiv);
                    row.appendChild(hintSpan);
                    filterControlsContainer.appendChild(row);
                });
            }

            // Rename renderWeightUI placeholder and implement
            function renderFieldConfigUI() {
                console.log("Rendering Field Config UI (Weights & Toggles)");
                if (!fieldConfigContainer) return;

                fieldConfigContainer.innerHTML = ''; // Clear previous content

                if (!availableFields || availableFields.length === 0) {
                    fieldConfigContainer.innerHTML = '<p class="text-muted small">Load data first to configure fields.</p>';
                    return;
                }

                availableFields.forEach(field => {
                    // Make sure fieldEnabledStatus has an entry; default to true if it doesn't (should have been set in processLoadedData)
                    const isEnabled = fieldEnabledStatus.hasOwnProperty(field) ? fieldEnabledStatus[field] : true;
                    const currentWeight = fieldWeights[field] !== undefined ? fieldWeights[field] : 100; // Default 100

                    const row = document.createElement('div');
                    row.className = 'd-flex align-items-center mb-2 p-2 border-bottom'; // Row styling
                    if (!isEnabled) {
                        row.style.opacity = '0.6'; // Dim disabled fields
                    }

                    // Field Name Label
                    const label = document.createElement('label');
                    label.textContent = field;
                    label.className = 'me-auto fw-bold'; // Push others right, make bold
                    label.style.minWidth = '150px'; // Give label some space
                    label.title = field; // Show full name on hover if needed

                    // Enabled Checkbox
                    const enabledWrapper = document.createElement('div');
                    enabledWrapper.className = 'form-check form-switch me-3';
                    const enabledCheckbox = document.createElement('input');
                    enabledCheckbox.type = 'checkbox';
                    enabledCheckbox.className = 'form-check-input';
                    enabledCheckbox.checked = isEnabled;
                    enabledCheckbox.id = `enable-${field.replace(/\W/g, '_')}`; // Create safe ID
                    enabledCheckbox.title = isEnabled ? 'Disable this field' : 'Enable this field';
                    enabledCheckbox.addEventListener('change', (e) => {
                        const newStatus = e.target.checked;
                        fieldEnabledStatus[field] = newStatus;
                        saveEnabledStatusToStorage();
                        // Dim/undim row immediately
                        row.style.opacity = newStatus ? '1' : '0.6';
                        // Update weight input disabled state
                        const weightInput = row.querySelector('input[type="number"]');
                        if (weightInput) weightInput.disabled = !newStatus;
                        // Re-render filters as available fields changed
                        renderFilterUI();
                        // Re-apply filters immediately to reflect enabled/disabled fields in output
                        applyFilters();
                    });
                    enabledWrapper.appendChild(enabledCheckbox);
                    const enabledLabel = document.createElement('label'); // Optional label for switch
                    enabledLabel.className = 'form-check-label small';
                    enabledLabel.htmlFor = enabledCheckbox.id;
                    enabledLabel.textContent = 'Enabled';
                    enabledWrapper.appendChild(enabledLabel);

                    // Weight Input
                    const weightWrapper = document.createElement('div');
                    weightWrapper.className = 'd-flex align-items-center';
                    const weightInput = document.createElement('input');
                    weightInput.type = 'number';
                    weightInput.min = 0;
                    weightInput.max = 100;
                    weightInput.step = 1;
                    weightInput.className = 'form-control form-control-sm';
                    weightInput.style.width = '80px'; // Fixed width for weight input
                    weightInput.value = currentWeight;
                    weightInput.title = `Weight for ${field} (0-100)`;
                    weightInput.disabled = !isEnabled; // Disable weight if field is disabled
                    weightInput.addEventListener('input', (e) => {
                        let weight = parseInt(e.target.value, 10);
                        if (isNaN(weight)) {
                             weight = 100; // Default if invalid input
                        } else {
                             weight = Math.max(0, Math.min(100, weight)); // Clamp value
                        }
                        fieldWeights[field] = weight;
                        // Save immediately on input change? Or add a save button?
                        // Saving immediately for simplicity now.
                        saveWeightsToStorage();
                        // Update the input value in case it was clamped
                        e.target.value = weight;
                    });
                    weightWrapper.appendChild(weightInput);
                    const weightLabel = document.createElement('span');
                    weightLabel.className = 'ms-1 small';
                    weightLabel.textContent = '%';
                    weightWrapper.appendChild(weightLabel);

                    // Append elements to row
                    row.appendChild(label);
                    row.appendChild(enabledWrapper);
                    row.appendChild(weightWrapper);

                    fieldConfigContainer.appendChild(row);
                });
            }

            // --- Apply Filters Function (Preparation Tab) ---
            function applyFilters() {
                console.log("Applying filters:", JSON.parse(JSON.stringify(currentFilters)));
                console.log("Data to filter:", fullProcessedData.length);
                console.log("Enabled status:", fieldEnabledStatus);

                if (!outputArea || !filterResultsCount) return; // Check if elements exist

                if (!fullProcessedData || fullProcessedData.length === 0) {
                    outputArea.textContent = 'No data loaded to filter.';
                    filterResultsCount.textContent = '(0 records)';
                    return;
                }

                const activeFilters = currentFilters.filter(f => f.field && f.field !== '' && f.operator); // Also ensure operator exists

                let filteredData = fullProcessedData;

                if (activeFilters.length > 0) {
                     filteredData = fullProcessedData.filter(item => {
                         if (!item || !item.processed_data) return false;

                         for (const filter of activeFilters) {
                             const itemValue = item.processed_data[filter.field];
                             const filterValue = filter.value;
                             const operator = filter.operator;

                             // --- Multi-Select Handling ---
                             if (Array.isArray(filterValue)) {
                                const itemValueStr = String(itemValue);
                                // Treat multi-select as 'equals any of' or 'not equals any of'
                                if (operator === '=') {
                                    // Item's value must be present in the selected array
                                    if (!filterValue.includes(itemValueStr)) return false;
                                } else if (operator === '!=') {
                                    // Item's value must NOT be present in the selected array
                                    if (filterValue.includes(itemValueStr)) return false;
                                } else {
                                    // Unsupported operator for multi-select
                                    console.warn(`Operator '${operator}' not directly supported for multi-select field '${filter.field}'. Filter skipped or potentially incorrect.`);
                                    // For now, let's treat unsupported as "fail the filter" to be safe
                                    return false;
                                }
                                continue; // Move to next filter if this one passed
                             }

                             // --- Single Value Handling ---
                             const filterValueStr = String(filterValue || ''); // Ensure it's a string
                             // Check if the item value exists and is not null/undefined/empty string/placeholder '-'
                             const valueExists = !(itemValue === null || itemValue === undefined || String(itemValue).trim() === '' || String(itemValue).trim() === '-');

                             // Handle 'exists' / 'notExists' first
                             if (operator === 'exists') {
                                 if (!valueExists) return false; // Fail if value doesn't exist
                                 continue; // Pass if value exists
                             }
                             if (operator === 'notExists') {
                                 if (valueExists) return false; // Fail if value exists
                                 continue; // Pass if value doesn't exist
                             }

                             // If operator requires a value, but item doesn't have one, it fails (unless comparing empty strings)
                             if (!valueExists) {
                                // Special case: Check if comparing empty/null strings
                                if ((operator === '=' || operator === '!=') && (filterValueStr === '' || filterValueStr === 'null' || filterValueStr === 'undefined')) {
                                    const isItemEmpty = !valueExists;
                                    const isFilterConsideredEmpty = (filterValueStr === '' || filterValueStr === 'null' || filterValueStr === 'undefined');
                                    if (operator === '=' && isItemEmpty !== isFilterConsideredEmpty) return false;
                                    if (operator === '!=' && isItemEmpty === isFilterConsideredEmpty) return false;
                                    continue; // Passed empty comparison
                                } else {
                                     // Item has no value, but filter requires one and isn't comparing empties
                                     return false;
                                }
                             }

                             // --- Comparisons when item value exists ---
                             const itemValueStr = String(itemValue).toLowerCase();
                             const filterValueLower = filterValueStr.toLowerCase();
                             const itemNum = parseFloat(itemValue); // Try converting item value to number
                             const filterNum = parseFloat(filterValueStr); // Try converting filter value to number
                             let numericComparisonDone = false;

                             // Attempt Numeric Comparison first if both seem numeric
                             if (!isNaN(itemNum) && !isNaN(filterNum)) {
                                numericComparisonDone = true;
                                switch (operator) {
                                    case '=': if (!(itemNum === filterNum)) return false; break;
                                    case '>': if (!(itemNum > filterNum)) return false; break;
                                    case '<': if (!(itemNum < filterNum)) return false; break;
                                    case '>=': if (!(itemNum >= filterNum)) return false; break;
                                    case '<=': if (!(itemNum <= filterNum)) return false; break;
                                    case '!=': if (!(itemNum !== filterNum)) return false; break;
                                    default: numericComparisonDone = false; // Operator not numeric
                                }
                             } else {
                                 // If we intended a numeric comparison but failed, should we fail the filter?
                                 // E.g., user enters '>' but value is 'N/A'
                                 if (['>', '<', '>=', '<='].includes(operator)) {
                                     console.warn(`Numeric comparison operator '${operator}' used, but values are not both numeric: Field='${filter.field}', Item='${itemValue}', Filter='${filterValueStr}'. Filter fails.`);
                                     return false; // Fail if numeric comparison intended but not possible
                                 }
                                 // Otherwise, allow string comparison for '=', '!=', 'contains', etc.
                                 numericComparisonDone = false;
                             }

                             // --- String Comparison (if numeric didn't happen or wasn't applicable) ---
                             if (!numericComparisonDone) {
                                switch(operator) {
                                    case '=': if (!(itemValueStr === filterValueLower)) return false; break;
                                    case '!=': if (!(itemValueStr !== filterValueLower)) return false; break;
                                    case 'contains': if (!itemValueStr.includes(filterValueLower)) return false; break;
                                    case 'startsWith': if (!itemValueStr.startsWith(filterValueLower)) return false; break;
                                    case 'endsWith': if (!itemValueStr.endsWith(filterValueLower)) return false; break;
                                    // Numeric operators already handled or failed above
                                }
                             }
                         }
                         // If we got through all filters for this item
                         return true;
                     });
                }

                 // --- Transform data for display (remove disabled fields) ---
                 const dataForDisplay = filteredData.map(item => {
                     const displayItem = {
                         ticker: item.ticker,
                         processed_data: {
                             // Optionally include specific default fields even if disabled?
                         },
                         // Don't include error field by default unless needed
                         // error: item.error
                     };
                     if (item.processed_data) {
                         for (const field in item.processed_data) {
                             // Only include the field if it exists and is explicitly enabled
                             // Check hasOwnProperty for safety, and check the enabled status map
                             if (item.processed_data.hasOwnProperty(field) && fieldEnabledStatus[field] === true) {
                                 displayItem.processed_data[field] = item.processed_data[field];
                             }
                         }
                     }
                     // Add error back if it exists
                     if (item.error) {
                         displayItem.error = item.error;
                     }
                     return displayItem;
                 });
                 // --- End Transformation ---

                 // Display results using the transformed data
                 outputArea.textContent = JSON.stringify(dataForDisplay, null, 2);
                 filterResultsCount.textContent = `Showing ${filteredData.length} matching records (out of ${fullProcessedData.length}).`; // Count based on filtered records

                 // --- Update data used for chart and render --- 
                 filteredDataForChart = filteredData; // Store the data before transformation
                 renderScatterPlot(); // Update chart when filters change
                 // --- End Chart Update --- 
            }
            // --- END applyFilters definition ---

            // --- NEW: Populate Report Field Selector --- 
            function populateReportFieldSelector() {
                console.log("Populating report field selector...");
                if (!reportFieldSelector) return;

                const previousValue = reportFieldSelector.value; // Remember selection
                reportFieldSelector.innerHTML = '<option value="">-- Select Field --</option>'; // Clear and add default

                if (!availableFields || availableFields.length === 0) {
                    console.log("No available fields to populate report selector.");
                    return;
                }

                // Filter available fields based on enabled status
                const enabledFields = availableFields.filter(field => fieldEnabledStatus[field] === true);
                console.log("Populating report selector with enabled fields:", enabledFields);

                enabledFields.forEach(field => {
                    const option = document.createElement('option');
                    option.value = field;
                    option.textContent = field;
                    reportFieldSelector.appendChild(option);
                });

                // Try to restore previous selection
                if (enabledFields.includes(previousValue)) {
                    reportFieldSelector.value = previousValue;
                } else {
                    // If previous selection is no longer valid (e.g., disabled), reset chart
                    if (reportChartInstance) {
                        reportChartInstance.destroy();
                        reportChartInstance = null;
                    }
                    if (chartStatus) chartStatus.textContent = 'Select a field to generate the chart.';
                }
            }
            // --- END Populate Report Field Selector ---

            // --- NEW: Populate Report Color Selector --- 
            function populateReportColorSelector() {
                console.log("Populating report color selector...");
                if (!reportColorSelector) return;

                const previousValue = reportColorSelector.value; // Remember selection
                reportColorSelector.innerHTML = '<option value="">-- No Color Variation --</option>'; // Clear and add default

                if (!availableFields || availableFields.length === 0) {
                    console.log("No available fields to populate color selector.");
                    return;
                }

                // Use the same enabled fields as the main selector
                const enabledFields = availableFields.filter(field => fieldEnabledStatus[field] === true);
                console.log("Populating color selector with enabled fields:", enabledFields);

                enabledFields.forEach(field => {
                    const option = document.createElement('option');
                    option.value = field;
                    option.textContent = field;
                    // Maybe exclude the currently selected Y-axis field?
                    // if (reportFieldSelector && field === reportFieldSelector.value) {
                    //     option.disabled = true;
                    // }
                    reportColorSelector.appendChild(option);
                });

                // Try to restore previous selection
                if (enabledFields.includes(previousValue)) {
                    reportColorSelector.value = previousValue;
                } else {
                    // If previous selection is no longer valid, just reset to default
                    reportColorSelector.value = "";
                }
            }
            // --- END Populate Report Color Selector ---

            // --- NEW: Render Scatter Plot --- 
            function renderScatterPlot() {
                console.log("Rendering scatter plot...");
                if (!reportFieldSelector || !reportChartCanvas || !chartStatus || !reportColorSelector) { // Added color selector check
                    console.error("Report tab elements not found.");
                    return;
                }

                const selectedField = reportFieldSelector.value;
                const colorField = reportColorSelector.value; // NEW: Get color field
                console.log(`Selected Y-axis field: ${selectedField}, Color by field: ${colorField}`);

                chartStatus.textContent = ''; // Clear previous status

                if (!selectedField) {
                    chartStatus.textContent = 'Please select a field from the dropdown.';
                    // Destroy existing chart if no field is selected
                    if (reportChartInstance) {
                        reportChartInstance.destroy();
                        reportChartInstance = null;
                    }
                    return;
                }

                if (!filteredDataForChart || filteredDataForChart.length === 0) {
                    chartStatus.textContent = 'No data available to plot (apply filters or load data).';
                    if (reportChartInstance) {
                        reportChartInstance.destroy();
                        reportChartInstance = null;
                    }
                    return;
                }

                // Color mapping logic
                const colorMap = {};
                const predefinedColors = [
                    'rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)',
                    'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)',
                    'rgba(199, 199, 199, 0.7)', 'rgba(83, 102, 255, 0.7)', 'rgba(40, 159, 64, 0.7)',
                    'rgba(210, 99, 132, 0.7)'
                     // Add more colors if needed
                ];
                let colorIndex = 0;
                const defaultColor = 'rgba(128, 128, 128, 0.6)'; // Default for missing color value

                // Function to get or assign a color
                const getColorForValue = (value) => {
                    if (value === null || value === undefined || value === '') return defaultColor;
                    const valueStr = String(value);
                    if (!colorMap[valueStr]) {
                        colorMap[valueStr] = predefinedColors[colorIndex % predefinedColors.length];
                        colorIndex++;
                    }
                    return colorMap[valueStr];
                };

                console.log(`Generating plot for field: ${selectedField} with ${filteredDataForChart.length} filtered records.`);

                // Prepare data for scatter plot: { x: index, y: value, ticker: ticker, colorValue: colorValue }
                const plotData = [];
                const pointBackgroundColors = [];
                const pointBorderColors = [];
                let nonNumericCount = 0;

                filteredDataForChart.forEach((item, index) => {
                    let pointColor = defaultColor;
                    let colorValue = null;

                    if (item && item.processed_data) {
                        // Get Y-axis value
                        if (item.processed_data.hasOwnProperty(selectedField)) {
                            const rawYValue = item.processed_data[selectedField];
                            const numericYValue = Number(rawYValue);

                            if (!isNaN(numericYValue) && rawYValue !== null && rawYValue !== '') {
                                // Get color field value if a color field is selected
                                if (colorField && item.processed_data.hasOwnProperty(colorField)) {
                                    colorValue = item.processed_data[colorField];
                                    pointColor = getColorForValue(colorValue);
                                } else if (!colorField) {
                                    // Use a default single color if no color field selected
                                    pointColor = predefinedColors[0]; 
                                }

                                plotData.push({
                                    x: index,
                                    y: numericYValue,
                                    ticker: item.ticker || 'N/A',
                                    colorValue: colorValue // Store for potential tooltip use
                                });
                                pointBackgroundColors.push(pointColor);
                                pointBorderColors.push(pointColor.replace('0.7', '1').replace('0.6', '1')); // Make border solid

                            } else {
                                nonNumericCount++; // Y-value is non-numeric
                            }
                        } else {
                            nonNumericCount++; // Missing Y-value field
                        }
                    } else {
                         nonNumericCount++; // Missing processed_data
                    }
                });

                if (plotData.length === 0) {
                    chartStatus.textContent = `No numeric data found for field '${selectedField}' in the current filtered data.`;
                     if (reportChartInstance) {
                        reportChartInstance.destroy();
                        reportChartInstance = null;
                    }
                    return;
                }

                if (nonNumericCount > 0) {
                    chartStatus.textContent = `Plotting ${plotData.length} numeric points. ${nonNumericCount} records were excluded due to missing or non-numeric values for '${selectedField}'.`;
                }

                const ctx = reportChartCanvas.getContext('2d');

                // Destroy previous chart instance if it exists
                if (reportChartInstance) {
                    reportChartInstance.destroy();
                }

                // Create the scatter chart
                reportChartInstance = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: selectedField, // Use field name as dataset label (for legend/tooltip)
                            data: plotData,
                            backgroundColor: pointBackgroundColors, // Use generated color array
                            borderColor: pointBorderColors, // Use generated color array
                            pointRadius: 5,
                            pointHoverRadius: 7
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Record Index (in filtered list)'
                                },
                                type: 'linear', // Ensure x-axis is treated as linear
                                position: 'bottom'
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: selectedField // Y-axis label is the selected field
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true, // Ensure legend is displayed
                                position: 'top',
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        // context.raw should contain {x, y, ticker, colorValue}
                                        const pointData = context.raw;
                                        if (pointData) {
                                            let label = `Ticker: ${pointData.ticker}`; 
                                            label += `\n${context.dataset.label || 'Value'}: ${pointData.y}`;
                                            if (colorField && pointData.colorValue !== null) {
                                                label += `\n${colorField}: ${pointData.colorValue}`;
                                            }
                                            return label.split('\n'); // Return as array for multi-line tooltips
                                        } 
                                        return ''; // Default tooltip if raw data missing
                                    }
                                }
                            }
                        }
                    }
                });

                console.log("Scatter plot rendered successfully.");
            }
            // --- END Render Scatter Plot --- 

            // --- Data Loading & State Update (Preparation Tab) ---
             function processLoadedDataAndUpdateState() {
                 if (!fullProcessedData || fullProcessedData.length === 0) {
                     availableFields = [];
                     fieldMetadata = {}; // Clear metadata if no data
                     // Keep loaded weights/enabled status? Or clear them?
                     // Let's keep them for now, in case user reloads data.
                     // fieldWeights = {};
                     // fieldEnabledStatus = {};
                     console.log("No processed data loaded or data is empty.");
                     // Re-render empty UIs
                     renderFieldConfigUI();
                     renderFilterUI();
                     applyFilters(); // Clear output area if needed
                     return;
                 }

                 // --- Discover Fields ---
                 const discoveredFields = new Set();
                 fullProcessedData.forEach(item => {
                     if (item && item.processed_data) {
                         Object.keys(item.processed_data).forEach(key => discoveredFields.add(key));
                     }
                 });
                 availableFields = [...discoveredFields].sort();
                 console.log("Discovered fields:", availableFields);

                 // --- Calculate Metadata ---
                 const newFieldMetadata = {};
                 const MAX_UNIQUE_TEXT_VALUES = 100; // Limit for text dropdowns
                 availableFields.forEach(field => {
                    const values = [];
                    let numericCount = 0;
                    let nonNullCount = 0;
                    let min = Infinity;
                    let max = -Infinity;
                    const uniqueTextValues = new Set();

                    fullProcessedData.forEach(item => {
                        if (item && item.processed_data && item.processed_data.hasOwnProperty(field)) {
                             const value = item.processed_data[field];
                             // Consider value valid if not null, undefined, or placeholder '-' or empty string
                             if (value !== null && value !== undefined && String(value).trim() !== '' && String(value).trim() !== '-') {
                                 values.push(value);
                                 nonNullCount++;
                                 const num = Number(value);
                                 if (!isNaN(num)) {
                                     numericCount++;
                                     if (num < min) min = num;
                                     if (num > max) max = num;
                                 } else {
                                     // Collect unique non-numeric strings (up to a limit)
                                     if (uniqueTextValues.size < MAX_UNIQUE_TEXT_VALUES) {
                                          uniqueTextValues.add(String(value)); // Store as string
                                     }
                                 }
                             }
                        }
                    });

                    if (nonNullCount === 0) {
                        newFieldMetadata[field] = { type: 'empty' }; // Field exists but no valid values
                    } else if (numericCount / nonNullCount >= 0.8) { // Heuristic: >= 80% numeric?
                        newFieldMetadata[field] = { type: 'numeric', min: min === Infinity ? 'N/A' : min, max: max === -Infinity ? 'N/A' : max };
                    } else {
                        // Only provide uniqueValues if the count is manageable and > 0
                        const uniqueValuesArray = uniqueTextValues.size > 0 && uniqueTextValues.size <= MAX_UNIQUE_TEXT_VALUES
                                                  ? [...uniqueTextValues].sort()
                                                  : [];
                        newFieldMetadata[field] = { type: 'text', uniqueValues: uniqueValuesArray };
                    }
                 });
                 fieldMetadata = newFieldMetadata; // Update global metadata
                 console.log("Calculated field metadata:", fieldMetadata);

                 // --- Initialize Weights & Enabled Status for New Fields ---
                 let weightsChanged = false;
                 let statusChanged = false;
                 availableFields.forEach(field => {
                     // Default weight 100 if not present
                     if (!(field in fieldWeights)) {
                         fieldWeights[field] = 100;
                         weightsChanged = true;
                         console.log(`Initialized weight for new field '${field}' to 100.`);
                     }
                     // Default enabled status true if not present
                     if (!(field in fieldEnabledStatus)) {
                         fieldEnabledStatus[field] = true;
                         statusChanged = true;
                         console.log(`Initialized enabled status for new field '${field}' to true.`);
                     }
                 });

                 // Optional: Clean up weights/status for fields no longer present in the data
                 // This prevents the config UI showing fields that don't exist in the current dataset
                 const currentAvailableSet = new Set(availableFields);
                 Object.keys(fieldWeights).forEach(field => {
                    if (!currentAvailableSet.has(field)) {
                        console.log(`Removing stale weight config for field '${field}'.`);
                        delete fieldWeights[field];
                        weightsChanged = true;
                    }
                 });
                 Object.keys(fieldEnabledStatus).forEach(field => {
                     if (!currentAvailableSet.has(field)) {
                         console.log(`Removing stale enabled status for field '${field}'.`);
                         delete fieldEnabledStatus[field];
                         statusChanged = true;
                     }
                 });

                 // Save if defaults were added or stale entries removed
                 if (weightsChanged) saveWeightsToStorage();
                 if (statusChanged) saveEnabledStatusToStorage();

                 // --- Re-render UIs ---
                 renderFieldConfigUI(); // Render config first (populates fieldEnabledStatus)
                 renderFilterUI(); // Then render filters (uses fieldEnabledStatus)
                 populateReportFieldSelector(); // --- ADD THIS CALL ---
                 populateReportColorSelector(); // --- ADD THIS CALL TOO ---
             }

            // --- Button Listeners (Preparation Tab) ---
            // Add Filter Button
             if (addFilterBtn) {
                 addFilterBtn.addEventListener('click', () => {
                     console.log("Add Filter clicked");
                     // Add a new blank filter object including comment
                     currentFilters.push({ id: Date.now() + Math.random(), field: '', operator: '=', value: '', comment: '' });
                     // Don't save here, let Apply Filters or Remove handle saving
                     renderFilterUI();
                 });
             }

            // Apply Filters Button
            if (applyFiltersBtn) {
                applyFiltersBtn.addEventListener('click', () => {
                    console.log("Apply Filters clicked - Current Filter State:", JSON.parse(JSON.stringify(currentFilters)));
                    // NOTE: The `currentFilters` array should already be up-to-date
                    // due to the 'change'/'input' listeners on the select/input fields.
                    // We just need to save this state before applying.
                    saveFiltersToStorage();
                    applyFilters(); // Apply the filters using the current state
                });
            }

            // Reset Filters Button
            if (resetFiltersBtn) {
                resetFiltersBtn.addEventListener('click', () => {
                     console.log("Reset Filters clicked");
                     // Reset filters to a single blank one including comment
                     currentFilters = [{ id: Date.now() + Math.random(), field: '', operator: '=', value: '', comment: '' }];
                     saveFiltersToStorage(); // Save the reset state
                     renderFilterUI();
                     applyFilters(); // Re-apply filters (which should now show all data)
                });
            }

            // Process Data Button (Load from DB)
            if (processButton && processStatus && outputArea) {
                processButton.addEventListener('click', async function() {
                    processButton.disabled = true;
                    showSpinner(processButton); // Show spinner
                    processStatus.textContent = 'Processing data...';
                    processStatus.className = 'ms-2 text-info';
                    outputArea.textContent = ''; // Clear previous output
                    if(filterResultsCount) filterResultsCount.textContent = ''; // Clear count

                    try {
                        // Step 1: Call the endpoint to process and store data (using the backend python function)
                        console.log("Calling /api/analytics/process-raw-data endpoint...");
                        const processResponse = await fetch('/api/analytics/process-raw-data', {
                            method: 'POST',
                            headers: { 'Accept': 'application/json' }
                        });

                        const processResult = await processResponse.json();

                        if (!processResponse.ok) {
                            const errorDetail = processResult.detail || `Processing failed with status ${processResponse.status} - ${processResponse.statusText}`;
                            console.error("Error response from process-raw-data:", processResult);
                            throw new Error(errorDetail);
                        }

                        console.log("Process request successful:", processResult);
                        processStatus.textContent = processResult.message || 'Processing request successful.';
                        processStatus.className = 'ms-2 text-success';

                        // Step 2: Call the endpoint to get the processed data
                        console.log("Calling /api/analytics/get-processed-data endpoint...");
                        const getResponse = await fetch('/api/analytics/get-processed-data', {
                            method: 'GET',
                            headers: { 'Accept': 'application/json' }
                        });

                        if (!getResponse.ok) {
                             const getErrorResult = await getResponse.json();
                             const getErrorDetail = getErrorResult.detail || `Failed to get processed data with status ${getResponse.status} - ${getResponse.statusText}`;
                             console.error("Error response from get-processed-data:", getErrorResult);
                             throw new Error(getErrorDetail);
                        }

                        const processedData = await getResponse.json();
                        console.log(`Successfully fetched ${processedData.length} processed records.`);
                        fullProcessedData = processedData;

                        // Step 3: Process loaded data (extract fields, init weights/status)
                        console.log("Processing loaded data and updating state...");
                        processLoadedDataAndUpdateState();

                        // Step 4: Display initial unfiltered data (or apply loaded filters)
                        console.log("Applying initial filters...");
                        applyFilters();

                    } catch (error) {
                        console.error('Error during Finviz data processing/fetching:', error);
                        outputArea.textContent = `An error occurred. Check console for details. \nError: ${error.message}`;
                        processStatus.textContent = `Error: ${error.message || 'An unknown error occurred.'}`;
                        processStatus.className = 'ms-2 text-danger';
                        fullProcessedData = []; // Clear data on error
                        processLoadedDataAndUpdateState(); // Re-render UIs (will show empty state)
                    } finally {
                         processButton.disabled = false;
                         console.log("Processing/fetching finished.");
                         hideSpinner(processButton); // Hide spinner
                    }
                });
            }

            // --- Helper functions to toggle button spinner/text --- 
            function showSpinner(button, otherButton) {
                const spinner = button.querySelector('.spinner-border');
                const text = button.querySelector('.button-text');
                if (spinner) spinner.style.display = 'inline-block';
                if (text) text.style.display = 'none';
                button.disabled = true;
                if (otherButton) otherButton.disabled = true; // Disable other button too
            }

            function hideSpinner(button, otherButton) {
                const spinner = button.querySelector('.spinner-border');
                const text = button.querySelector('.button-text');
                if (spinner) spinner.style.display = 'none';
                if (text) text.style.display = 'inline-block'; 
                
                // Re-enable the current button
                button.disabled = false;

                // Re-enable the other button conditionally
                if (otherButton) {
                    // If the other button is the upload button, only enable it if tickers are loaded
                    if (otherButton.id === 'run-finviz-upload-btn') {
                        if (uploadedTickers.length > 0) {
                            otherButton.disabled = false;
                        }
                    } else {
                        // Otherwise (if other button is the screened fetch), always re-enable it
                        otherButton.disabled = false;
                    }
                }
            }
            // --- End Helper Functions --- 

            // --- Initial Page Load Logic ---
            console.log("Initial page load: Loading state from localStorage...");
            loadFiltersFromStorage();
            loadWeightsFromStorage();
            loadEnabledStatusFromStorage();
            // Initial render based on loaded state (data is empty initially)
            renderFilterUI(); // Render Prep tab UI elements
            renderFieldConfigUI();
            // Optionally trigger the "Load Data from DB" automatically on page load?
            // processButton.click(); // Uncomment to auto-load data
            
            // --- NEW: Add Event Listener for Report Field Selector ---
            if (reportFieldSelector) {
                reportFieldSelector.addEventListener('change', renderScatterPlot);
            }
            // --- END Event Listener ---
            
            // --- NEW: Add Event Listener for Report Color Selector ---
            if (reportColorSelector) {
                reportColorSelector.addEventListener('change', renderScatterPlot);
            }
            // --- END Event Listener ---

            console.log("Initial page load complete.");

        });
    </script>
{% endblock %} 